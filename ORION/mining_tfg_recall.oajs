//************ YOU MUST DO **********
//1 - PUT A BAG IN YOUR BANK AND ADD AS AN OBOJECT NAMED: miningBox
//2 - SET THE MINE POSITION ON THE mineRectangle VARIABLE(OBJECT)

var infoColor = 0x0185;
var errorColor = 0x0020;
var debugColor = 0x45F

var mineIndex = 8;
var mineRectangle = [
			{ Xsmall: 2565, Xbig:2599 , Ysmall: 429 , Ybig: 479,  rune: 2, active: false }, //Minoc
			{ Xsmall: 346, Xbig:389 , Ysmall: 1426 , Ybig: 1457, rune: 8, active: true }, //Mountain of Knowledge (limit 5 tiles from exit) top
			{ Xsmall: 1361, Xbig:1388 , Ysmall: 2705 , Ybig: 2724, rune: 6, active: true }, //Haunted Montain
			{ Xsmall: 4805, Xbig:4817 , Ysmall: 3632 , Ybig: 3665, rune: 4, active: true },  //Monte Tresshorn - Fire Island
			{ Xsmall: 1253, Xbig:1278 , Ysmall: 1211 , Ybig: 1234, rune: 13, active: true }, //Golden Mine
			{ Xsmall: 987, Xbig:1012 , Ysmall: 1574 , Ybig: 1597, rune: 9, active: true }, //Enchanted Mine
			{ Xsmall: 1414, Xbig:1435 , Ysmall: 2878 , Ybig: 2892, rune: 12, active: true }, //Mount of Darkness
			{ Xsmall: 2315, Xbig:2337 , Ysmall: 813 , Ybig: 825, rune: 11, active: true }, //Valley of Light
			{ Xsmall: 2430, Xbig:2449 , Ysmall: 867 , Ybig: 909, rune: 14, active: true } //Covetuos Mine
				
				 ];  


				    
var miningRange = 100
var miningTools = '0x0E85|0x0E86';
var miningDelay=16000
var persist = false;
var bankweight = 380;
var oresType='0x19B7|0x19BA|0x19B8|0x19B9|0x0F0F|0x0F10|0x0F16|0x0F15|0x0F11|0x0F26|0x0F18|0x19B7|0x0F13'
var moveitemdelay=1500

var newSpotMsgs='Try mining elsewhere|There is nothing here|That is too far|You have no line of sight|You cannot mine so close'
var sameSpotMsgs='You put'
var persistSpotMsgs='You loosen some rocks but fail'
var toolUsageMsg='Where do you want to use'
var garbageOreMsg='Ceramic|Rusty|Old Copper|Rose|Dull Copper|Agapite|Bronze|Shadow|Copper|Silver|Verite|Valorite|Iron'

// DONT CHANGE THESE VARS
var timeout=-1;


function Autostart()
{
	Orion.Terminate('Mining');
	
	Orion.Exec('SetViewRange', true);

	Orion.Print(infoColor, 'MINING WILL START IN 20 SECONDS');

	Orion.Wait(20000);
	Orion.Exec('Mining', true);
	Orion.OptionAlwaysRun(false);
	
	
	//Only Activate AntiPlayer after recall complete
	var x = Player.X();
	while(x == Player.X())
		Orion.Wait(250);
		
		
	Orion.Exec('AntiPlayer', true);	
}

function SetViewRange(dummy){	
	Orion.ClientViewRange(21);
	Orion.Wait(500);
	Orion.Print(infoColor, 'View Range set to: ' + Orion.ClientViewRange() );	
}


function Mining(){

	var closest;
	var closestTile;
	var mineCoords = [];

	while(!Player.Dead() && Orion.Connected() )
	{
		DEBUG('Main Loop');
		
		 if( ! IsInBoundaires(Player.X(), Player.Y(), 2) ){
			DEBUG('Player NOT IsInBoundaires ');
		 	BankToMine();
		 	mineCoords = FindMinableSpots(miningRange);
		 }
		
		//if you dont have spots to this mine yet
		 if(mineCoords.length <= 0 )
		 	mineCoords = FindMinableSpots(miningRange);
		
		closest = GetClosest(mineCoords);
		closestTile = mineCoords[closest];
				 
		 if(!IsInBoundaires(closestTile.x, closestTile.y) ) {
		 		DEBUG2('Spot discarted: ' + closestTile.x + ', ' + closestTile.y  );
				mineCoords = Remove(mineCoords, closest);
				 if(mineCoords.length <= 0 ){
		 			DEBUG2('All mined. Let the mine rest! >2< ');
		 			ChangeMine();
		 		}
				Orion.Wait(1);
				continue;
       	}
       
		PathFinder(closestTile.x, closestTile.y);

		Orion.CancelTarget();
    		Orion.ClearJournal();
     		  
     		timeout = Orion.Now();

     		Orion.Print(infoColor, ' ');
     		Orion.Print(infoColor, ' '); 
     		
     		HidingAndStealth();
     		//fish stakes (yes, very lazy and arbitrary, but okay for an async function call)
     		Orion.UseType('0x097B');
		Dig(closestTile.x, closestTile.y);
		
		while( ( Orion.Now() - timeout ) < miningDelay ){    
		 	
     			if( Orion.InJournal(newSpotMsgs) || Orion.InJournal(garbageOreMsg) )
     			{	
     				DEBUG2('Garbage Ore/New spot (' +  (  Orion.Now() - timeout ) + 'ms)' );
				mineCoords = Remove(mineCoords, closest);
				break;
			}
			if( Orion.InJournal(persistSpotMsgs) )
			{
				DEBUG2('Persisting... (' +  (  Orion.Now() - timeout ) + 'ms)' );
				if(!persist)
					mineCoords = Remove(mineCoords, closest);
					
				break;
			}

			if( Orion.InJournal(sameSpotMsgs) ){
				DEBUG2('Good Spot (' +  (  Orion.Now() - timeout ) + 'ms)');
				break;
			}
				
     			Orion.Wait(50);
     		}
     		//if MaxWeight reached OR all spots removed 
     		if( (Player.Weight() >= bankweight && bankweight > 0) || (mineCoords.length <= 0) ){
     		
     			if(mineCoords.length <= 0)
     				DEBUG2('All mined. Let the mine rest !');
     			else
     				DEBUG2('Max weight reached');
     			
     			//get rid of all spots left 
     			mineCoords = [];
     			MineToBank();
			OreToBank();
			ChangeMine();
			BankToMine();
     		}
     		
		Orion.Wait(50);	
	}
}

function Dig(x, y)
{
	DEBUG('Dig: ' + x + ', ' + y);
	var tool = Orion.FindType(miningTools, '-1', self, 'item|first', '-1', '-1');
      
      if(tool.length == 0)
	      tool =  Orion.FindType(miningTools, '-1', backpack, 'item|first', '-1', '-1');

     if (tool.length == 0)
     {
     		Orion.Print(23, 'NO MINING TOOL. MACRO ABORTED');
     		Orion.Terminate('Mining')
     	}
     	
     	Orion.WaitTargetTile('mine', x , y, 0);
     	Orion.UseObject(tool[0]);
     	Orion.WaitJournal(toolUsageMsg, Orion.Now(), Orion.Now() + 5000, 'sys', -1, -1);
}

function FindMinableSpots( range )
{	
    var coord;    
    var mineCoords = [];
    
    for (x = Player.X() - range; x < Player.X() +range; ++x)
    {
        for (y = Player.Y() - range; y < Player.Y() + range; ++y)
        {
            if (Orion.ValidateTargetTile('mine', x, y))
            {
                coord = { x: x, y: y};            
                mineCoords.push(coord);        
            }
        }    
    }
    DEBUG('Found ' + mineCoords.length + ' tiles to mine');
    return mineCoords;
}

function GetClosest(minesArr)
{

    var px = Player.X();
    var py = Player.Y();
    
    var closest = 0;
    var dsq = 1000;
    
    for (var i =0; i < minesArr.length; ++i)
    {
        var dx = Math.abs(px - minesArr[i].x);
        var dy = Math.abs(py - minesArr[i].y);
    
        var dq = dx + dy;
        
       			 //cant mine under yourself
        if (dq < dsq && dq != 0)
        {
            dsq = dq;
            closest = i;
         }
    }
    DEBUG('GetClosest: ' + closest);
    return closest;
}

function Remove(arr, idx)
{
    var result = [];
    for (var i = 0; i < arr.length; ++i)
    {
        if (i != idx)
	        result.push(arr[i]);
    }
    
    DEBUG2('Tiles Left: ' + arr.length);
    return result;
}

function PathFinder(x, y)
{
	while(IsInBoundaires(x, y) && !Orion.WalkTo(x, y, -1, 2)){
		Orion.Wait(250);
		Orion.Print(31, 'Going to: ' + x + ', ' + y + ' Can walk: ' + Orion.CanWalk(Player.Direction(), x, y, -1));
	}
}

function IsInBoundaires(x, y, precision){
	
	if(!precision)
		precision = 0;


	DEBUG('P: ' + x + ', ' + y + ' - ' + precision);
	DEBUG('R: ' + mineRectangle[mineIndex].Xsmall + ', ' + mineRectangle[mineIndex].Xbig  + ', ' + mineRectangle[mineIndex].Ysmall + ', ' +  mineRectangle[mineIndex].Ybig );

	 if( x >= mineRectangle[mineIndex].Xsmall - precision  && x <= mineRectangle[mineIndex].Xbig + precision &&
	     y >= mineRectangle[mineIndex].Ysmall - precision  && y <= mineRectangle[mineIndex].Ybig + precision )
	{
		return true; //in side rectangle 
	}
	
	return false; //out side rectangle 
       	
}

function OreToBank(){


	Orion.Say('banker bank');		
	Orion.Wait(1000);	
	
	var bag = Orion.FindObject('miningBox');
	
	if(!bag)	{
		 Orion.Print(infoColor,'You have no deposit bag defined');
		 Orion.Terminate('Mining')
		 return;
	}
		
	var ores = Orion.FindType(oresType, '-1', backpack);

	for(var i = 0; i < ores.length; i++){
		Orion.MoveItem(ores[i], 0, bag.Serial());
		Orion.Wait(moveitemdelay);
	}
}

function MineToBank()
{
	Orion.Say('.recall 1 5');
	Orion.Wait(13000);
}

function BankToMine()
{
	Orion.Say('.recall 1 ' + mineRectangle[mineIndex].rune );
	Orion.Wait(13000);
	
}

function BuyPickAxe(dummy)
{
	
}

function Meditation(dummy)
{
	
}

function ChangeMine(dummy){

	mineIndex++;
	
	if(mineIndex >= mineRectangle.length )
		mineIndex = 0;
		
	while(!mineRectangle[mineIndex].active)
		mineIndex++;


}
function AntiPlayer() {

	var delay = 25;
	var range = 25;

	Orion.Ignore(self);

	while (Orion.Connected()) {
		Orion.Wait(delay);

		var pksFound = Orion.FindType('0x0190|0x0191', '-1', ground, 'human', range, 'red|blue|gray|orange');

		if (pksFound.length == 0) 
			continue;
			
		//IGNORE MAGINCIA BANK
		if (Player.X() > 3727 && Player.X() < 3744){
			if (Player.Y() < 2160 && Player.Y() > 2143){
				continue;
			}
		}	
		
		DEBUG2('AntiPlayer in ACTION');
		Orion.UseType('0x0F0E', '0x0001', backpack, true); //invis
		Orion.BlockMoving(true);
		Orion.Say('.recall 1 5');	// --> go to bank without	 delays
		Orion.Screenshot();
		Orion.Terminate('Mining');
		Orion.WarMode(false);
		Orion.Wait(5000);
		Orion.BlockMoving(false);
		Orion.Wait(6000);
 		OreToBank();
 		Orion.Wait(120000);
 		ChangeMine();
		Orion.Exec('Autostart', true);
	}
}

function HidingAndStealth(){

	var timer;
	
	if(Player.Hidden())
		return true;
	
	Orion.UseSkill('Hiding');
	Orion.ClearJournal();
		
	timer = Orion.Now();
	while(!Player.Hidden() && Orion.Now() - timer < 6000 ){
		
		if(Orion.InJournal('seem to hide here|hidden', 'my|sys', -1, -1, Orion.Now() -1000, Orion.Now() + 1000) ){
			DEBUG2('Hidding Delay: ' + (Orion.Now() - timer) );
			break;
		}
		Orion.Wait(50)
	}
		
	if(Player.Hidden()){
		
		Orion.UseSkill('Stealth');
		Orion.ClearJournal();
		
		Orion.WaitJournal('not hidden|quietly', Orion.Now(), Orion.Now() + 10000, 'my|sys',-1,-1);
		return true;
	}
	
	return false;
}

function DEBUG(msg){
	
	if(false)
		Orion.Print(debugColor, msg);
}

function DEBUG2(msg){
	
	if(true)
		Orion.Print(debugColor, msg);
}